DROP PROCEDURE IF EXISTS addNewAsset;DELIMITER $ CREATE PROCEDURE addNewAsset(IN type_id INT) BEGINDECLARE is_type_correct BOOLEAN;SELECT (SELECT COUNT(*) FROM asset_types WHERE asset_types.id = type_id) = 1INTO is_type_correct;IF NOT is_type_correct THENSELECT NULL AS id,idsNotFound('AssetType', type_id, is_type_correct) AS message;ELSEINSERT INTO assets (type)VALUES (type_id);SELECT LAST_INSERT_ID() AS id, NULL AS message;END IF; END $ DELIMITER ; DROP PROCEDURE IF EXISTS getAssetInfo;DELIMITER $ CREATE PROCEDURE getAssetInfo(IN asset_id INT) BEGINDECLARE Asset_room_id INT DEFAULT getRoomIdWithAsset(asset_id);SELECT assets.id,assets.type,asset_types.letter,asset_types.name AS asset_type_name,Asset_room_id AS room_id,rooms.name AS room_name,buildings.id AS building_id,buildings.name AS building_nameFROM assetsJOIN asset_types ON assets.type = asset_types.idLEFT JOIN rooms ON Asset_room_id = rooms.idLEFT JOIN buildings ON rooms.building = buildings.idWHERE assets.id = asset_id;END $ DELIMITER ; DROP PROCEDURE IF EXISTS getAssetsInRoom;DELIMITER $ CREATE PROCEDURE getAssetsInRoom(IN room_id INT) BEGINSELECT assets.id,assets.type,asset_types.name AS asset_type_name,asset_types.letter AS asset_type_letterFROM reports_positionsJOIN reports ON reports_positions.report_id = reports.idJOIN assets ON reports_positions.asset_id = assets.idJOIN asset_types ON assets.type = asset_types.idWHERE reports_positions.report_id = (SELECT r.idFROM reports AS rWHERE r.room = room_idORDER BY r.create_date DESC, r.id DESCLIMIT 1)AND reports_positions.presentAND reports.room = getRoomIdWithAsset(reports_positions.asset_id)ORDER BY assets.id ASC;END $ DELIMITER ; DROP PROCEDURE IF EXISTS addBuilding;DELIMITER $ CREATE PROCEDURE addBuilding(IN building_name VARCHAR(64)) BEGINDECLARE is_name_unique BOOLEAN;SELECT (SELECT COUNT(*) FROM buildings WHERE buildings.name = building_name) = 0INTO is_name_unique;IF NOT is_name_unique THENSELECT NULL AS id,CONCAT('Building name=', building_name, ' is not unique') AS message;ELSEINSERT INTO buildings (name)VALUES (building_name);SELECT LAST_INSERT_ID() AS id, NULL AS message;END IF; END $ DELIMITER ; DROP PROCEDURE IF EXISTS getBuildings;DELIMITER $ CREATE PROCEDURE getBuildings() BEGINSELECT buildings.id, buildings.nameFROM buildingsORDER BY buildings.id ASC;END $ DELIMITER ; DROP PROCEDURE IF EXISTS addNewReport;DELIMITER @ CREATE PROCEDURE addNewReport(IN report_name VARCHAR(64), IN report_room INT, IN report_owner INT,IN report_positions JSON) addNewReportProcedure: BEGINDECLARE I INT;DECLARE Is_room_correct BOOLEAN DEFAULT roomExists(report_room);DECLARE Is_owner_correct BOOLEAN DEFAULT userExists(report_owner);DECLARE ReportPositions_length INT;DECLARE Are_assets_exists BOOLEAN;DECLARE Assets_does_not_exists VARCHAR(1024);DECLARE Are_rooms_exists BOOLEAN;DECLARE Rooms_does_not_exists VARCHAR(1024);DECLARE Are_assets_duplicated BOOLEAN;DECLARE Assets_duplicated VARCHAR(1024);DECLARE New_report_id INT;IF NOT Is_room_correct OR NOT Is_owner_correct THENSELECT NULL AS id,CONCAT_WS(' AND ',idsNotFound('Room', report_room, Is_room_correct),idsNotFound('User', report_owner, Is_owner_correct)) AS message;LEAVE addNewReportProcedure;END IF;CREATE TEMPORARY TABLE ReportPositions(id INT,previous INT,present BOOLEAN);SET I = 0;SET ReportPositions_length = JSON_LENGTH(report_positions);WHILE (I < ReportPositions_length)DOINSERT INTO ReportPositionsSELECT JSON_VALUE(report_positions, CONCAT(' $[', i, '].id')) AS id,NULLIF(JSON_VALUE(report_positions, CONCAT('$[', i, '].previous')), 'null') AS previous,JSON_VALUE(report_positions, CONCAT('$[', i, '].present')) AS present;SET I = I + 1;END WHILE;SELECT COUNT(*) = 0,GROUP_CONCAT(DISTINCT ReportPositions.id ORDER BY ReportPositions.id SEPARATOR ', ')INTOAre_assets_exists,Assets_does_not_existsFROM ReportPositionsWHERE NOT assetExists(ReportPositions.id);SELECT COUNT(*) = 0,GROUP_CONCAT(DISTINCT ReportPositions.previous ORDER BY ReportPositions.previous SEPARATOR ', ')INTOAre_rooms_exists,Rooms_does_not_existsFROM ReportPositionsWHERE ReportPositions.previous IS NOT NULLAND NOT roomExists(ReportPositions.previous);SELECT COUNT(*) = 0,GROUP_CONCAT(DISTINCT duplicates.id ORDER BY duplicates.id SEPARATOR ', ')INTOAre_assets_duplicated,Assets_duplicatedFROM (SELECT ReportPositions.idFROM ReportPositionsGROUP BY ReportPositions.idHAVING COUNT(ReportPositions.id) > 1) AS duplicates;If NOT Are_assets_exists OR NOT Are_rooms_exists OR NOT Are_assets_duplicated THENSELECT NULL AS id,CONCAT_WS(' AND ',idsNotFound('Asset', Assets_does_not_exists, Are_assets_exists),idsNotFound('Room', Rooms_does_not_exists, Are_rooms_exists),haveDuplicates('Asset', Assets_duplicated, Are_assets_duplicated)) AS message;DROP TEMPORARY TABLE ReportPositions;LEAVE addNewReportProcedure;END IF;INSERT INTO reports (name, room, owner, create_date)VALUES (report_name, report_room, report_owner, NOW());SET New_report_id = LAST_INSERT_ID();INSERT INTO reports_positions (report_id, asset_id, previous_room, present)SELECT New_report_id,ReportPositions.id,ReportPositions.previous,ReportPositions.presentFROM ReportPositions;DROP TEMPORARY TABLE ReportPositions;SELECT New_report_id AS id, NULL AS message;END @ DELIMITER ; DROP PROCEDURE IF EXISTS getPositionsInReport;DELIMITER $ CREATE PROCEDURE getPositionsInReport(IN id_report INT) BEGINSELECT reports_positions.asset_id,reports_positions.present,assets.type AS type_id,asset_types.letter AS type_letter,asset_types.name AS type_name,rooms.id AS previous_id,rooms.name AS previous_name,buildings.id AS previous_building_id,buildings.name AS previous_building_nameFROM reports_positionsJOIN assets ON reports_positions.asset_id = assets.idJOIN asset_types ON assets.type = asset_types.idLEFT JOIN rooms ON reports_positions.previous_room = rooms.idLEFT JOIN buildings ON rooms.building = buildings.idWHERE reports_positions.report_id = id_report;END $ DELIMITER ; DROP PROCEDURE IF EXISTS getReportsHeaders; DROP PROCEDURE IF EXISTS getReportHeader; DROP PROCEDURE IF EXISTS _ReportsHeaders;DELIMITER $ CREATE PROCEDURE _ReportsHeaders(IN user_id INT, IN report_id INT) BEGINSELECT reports.id,reports.name,reports.create_date,users.id AS owner_id,users.login AS owner_name,rooms.id AS room_id,rooms.name AS room_name,buildings.id AS building_id,buildings.name AS building_nameFROM reportsJOIN users ON reports.owner = users.idJOIN rooms ON reports.room = rooms.idJOIN buildings ON rooms.building = buildings.idWHERE (user_id IS NULL OR users.id = user_id)AND (report_id IS NULL OR reports.id = report_id)ORDER BY reports.create_date DESC,reports.id DESC;END $ DELIMITER ;DELIMITER $ CREATE PROCEDURE getReportsHeaders(IN user_id INT) BEGINCALL _ReportsHeaders(user_id, NULL); END $ DELIMITER ;DELIMITER $ CREATE PROCEDURE getReportHeader(IN report_id INT) BEGINCALL _ReportsHeaders(NULL, report_id); END $ DELIMITER ; DROP PROCEDURE IF EXISTS addRoom;DELIMITER $ CREATE PROCEDURE addRoom(IN room_name VARCHAR(64), IN building_id INT) BEGINDECLARE is_building_correct BOOLEAN;DECLARE is_name_unique BOOLEAN;SELECT (SELECT COUNT(*) FROM buildings WHERE buildings.id = building_id) = 1INTO is_building_correct;SELECT (SELECT COUNT(*) FROM rooms WHERE rooms.building = building_id AND rooms.name = room_name) = 0INTO is_name_unique;IF NOT is_building_correct OR NOT is_name_unique THENSELECT NULL AS id,CONCAT_WS(' AND ',idsNotFound('Building', building_id, is_building_correct),CONCAT('Room name=', IF(NOT is_name_unique, room_name, NULL), ' is not unique in Building id=',building_id)) AS message;ELSEINSERT INTO rooms (name, building)VALUES (room_name, building_id);SELECT LAST_INSERT_ID() AS id, NULL AS message;END IF; END $ DELIMITER ; DROP PROCEDURE IF EXISTS getRooms;DELIMITER $ CREATE PROCEDURE getRooms(IN id_building INT) BEGINSELECT rooms.id,rooms.name,buildings.id AS building_id,buildings.name AS building_nameFROM roomsJOIN buildings ON rooms.building = buildings.idWHERE rooms.building = id_buildingORDER BY rooms.id ASC;END $ DELIMITER ; DROP PROCEDURE IF EXISTS addScan;DELIMITER $ CREATE PROCEDURE addScan(IN room_id INT, IN owner_id INT) BEGINDECLARE Is_room_correct BOOLEAN DEFAULT roomExists(room_id);DECLARE Is_owner_correct BOOLEAN DEFAULT userExists(owner_id);IF NOT Is_room_correct OR NOT Is_owner_correct THENSELECT NULL AS id,CONCAT_WS(' AND ',idsNotFound('Room', room_id, Is_room_correct),idsNotFound('User', owner_id, Is_owner_correct)) AS message;ELSEINSERT INTO scans (room, owner, create_date)VALUES (room_id, owner_id, NOW());SELECT LAST_INSERT_ID() AS id, NULL AS message;END IF;END $ DELIMITER ; DROP PROCEDURE IF EXISTS deleteScan;DELIMITER $ CREATE PROCEDURE deleteScan(IN scan_id INT) BEGINDELETEFROM scans_positionsWHERE scans_positions.scan = scan_id;DELETEFROM scansWHERE scans.id = scan_id;END $ DELIMITER ; DROP PROCEDURE IF EXISTS getScans;DELIMITER $ CREATE PROCEDURE getScans(IN user_id INT) BEGINSELECT scans.id,scans.create_date,users.id AS owner_id,users.login AS owner_name,rooms.id AS room_id,rooms.name AS room_name,buildings.id AS building_id,buildings.name AS building_nameFROM scansJOIN users ON scans.owner = users.idJOIN rooms ON scans.room = rooms.idJOIN buildings ON rooms.building = buildings.idWHERE scans.owner = user_idORDER BY reports.create_date DESC,reports.id DESC;END $ DELIMITER ; DROP PROCEDURE IF EXISTS updateScan;DELIMITER @ CREATE PROCEDURE updateScan(IN scan_id INT, IN scan_positions JSON) updateScanProcedure: BEGINDECLARE I INT;DECLARE ScanPositions_length INT;DECLARE Is_scan_correct BOOLEAN DEFAULT scanExists(scan_id);DECLARE Are_assets_exists BOOLEAN;DECLARE Assets_does_not_exists VARCHAR(1024);IF NOT Is_scan_correct THENSELECT NULL AS id,idsNotFound('Scan', scan_id, Is_scan_correct) AS message;LEAVE updateScanProcedure;END IF;CREATE TEMPORARY TABLE ScanPositions(asset INT);SET I = 0;SET ScanPositions_length = JSON_LENGTH(scan_positions);WHILE (I < ScanPositions_length)DOINSERT INTO ScanPositionsSELECT JSON_VALUE(scan_positions, CONCAT(' $[', i, ']')) AS asset;SET I = I + 1;END WHILE;SELECT COUNT(*) = 0,GROUP_CONCAT(DISTINCT ScanPositions.asset ORDER BY ScanPositions.asset SEPARATOR ', ')INTOAre_assets_exists,Assets_does_not_existsFROM ScanPositionsWHERE NOT assetExists(ScanPositions.asset);If NOT Are_assets_exists THENSELECT NULL AS id,idsNotFound('Asset', Assets_does_not_exists, Are_assets_exists) AS message;DROP TEMPORARY TABLE ScanPositions;LEAVE updateScanProcedure;END IF;INSERT INTO scans_positions (scan, asset)SELECT scan_id, ScanPositions.assetFROM ScanPositionsWHERE ScanPositions.asset NOT IN (SELECT sp.assetFROM scans_positions AS spWHERE sp.scan = scan_id);DELETEFROM scans_positionsWHERE scans_positions.scan = scan_idAND scans_positions.asset NOT IN (SELECT ScanPositions.assetFROM ScanPositions);END @ DELIMITER ; DROP PROCEDURE IF EXISTS addLoginSession;DELIMITER $ CREATE PROCEDURE addLoginSession(IN user_id INT, IN date_expiration DATETIME, IN user_token VARCHAR(64)) BEGINDECLARE is_type_correct BOOLEAN;SELECT (SELECT COUNT(*) FROM users WHERE users.id = user_id) = 1INTO is_type_correct;IF NOT is_type_correct THENSELECT NULL AS id,idsNotFound('User', user_id, is_type_correct) AS message;ELSEINSERT INTO login_sessions (user, token, expiration_date, create_date)VALUES (user_id, user_token, date_expiration, NOW());SELECT LAST_INSERT_ID() AS id, NULL AS message;END IF; END $ DELIMITER ; DROP PROCEDURE IF EXISTS deleteLoginSession;DELIMITER $ CREATE PROCEDURE deleteLoginSession(IN user_token VARCHAR(64)) BEGINDELETEFROM login_sessionsWHERE login_sessions.token = user_token;END $ DELIMITER ; DROP PROCEDURE IF EXISTS getLoginSession;DELIMITER $ CREATE PROCEDURE getLoginSession(IN user_token VARCHAR(64)) BEGINSELECT login_sessions.id,login_sessions.user AS user_id,login_sessions.expiration_date,login_sessions.token,login_sessions.expiration_date <= NOW() AS expiredFROM login_sessionsWHERE login_sessions.token = user_token;END $ DELIMITER ; DROP PROCEDURE IF EXISTS getUser;DELIMITER $ CREATE PROCEDURE getUser(IN user_id INT) BEGINSELECT users.id,users.login,users.hashFROM usersWHERE users.id = user_id;END $ DELIMITER ; DROP PROCEDURE IF EXISTS getUserByLogin;DELIMITER $ CREATE PROCEDURE getUserByLogin(IN user_login VARCHAR(64)) BEGINSELECT users.id,users.login,users.hashFROM usersWHERE users.login = user_login;END $ DELIMITER ; 